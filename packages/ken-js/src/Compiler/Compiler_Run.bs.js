// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Random = require("bs-platform/lib/js/random.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Graph_T$BsKen = require("../Graph/Graph_T.bs.js");
var RList$Rationale = require("rationale/src/RList.js");
var Option$Rationale = require("rationale/src/Option.js");
var IdConverter$BsKen = require("./IdConverter.bs.js");
var Compiler_AST$BsKen = require("./Compiler_AST.bs.js");
var Function$Rationale = require("rationale/src/Function.js");

function makeThingId(id) {
  return {
          rawId: id,
          tag: undefined,
          thingIdType: undefined,
          updatedId: undefined
        };
}

function thingIdKey(e) {
  return /* tuple */[
          e.rawId,
          e.tag
        ];
}

function allPrimaryIds(g) {
  var factIds = List.flatten(List.map((function (r) {
              return /* :: */[
                      r.thingId,
                      /* :: */[
                        r.subjectId,
                        /* :: */[
                          r.propertyId,
                          /* [] */0
                        ]
                      ]
                    ];
            }), g.facts));
  var aliasIds = $$Array.to_list(Js_dict.values(g.aliases));
  return List.append(aliasIds, factIds);
}

function findUniqueIds(g) {
  return RList$Rationale.uniqBy(thingIdKey, allPrimaryIds(g));
}

function tagFacts(g) {
  List.iter((function (fact) {
          Random.self_init(/* () */0);
          var nonce = String(Random.$$int(1000000));
          fact.thingId.tag = nonce;
          return /* () */0;
        }), g.facts);
  return g;
}

function useUniqueThingIds(g) {
  var uniqueIds = RList$Rationale.uniqBy(thingIdKey, allPrimaryIds(g));
  var findId = function (thingId) {
    return List.find((function (e) {
                  return Caml_obj.caml_equal(thingIdKey(e), thingIdKey(thingId));
                }), uniqueIds);
  };
  var facts = List.map((function (r) {
          var match = r.value;
          var tmp;
          tmp = match.tag ? /* Id */Block.__(1, [findId(match[0])]) : r.value;
          return {
                  thingId: findId(r.thingId),
                  subjectId: findId(r.subjectId),
                  propertyId: findId(r.propertyId),
                  isInversed: r.isInversed,
                  value: tmp
                };
        }), g.facts);
  var aliases = Js_dict.fromArray($$Array.map((function (param) {
              return /* tuple */[
                      param[0],
                      findId(param[1])
                    ];
            }), Js_dict.entries(g.aliases)));
  return {
          facts: facts,
          baseId: g.baseId,
          resourceId: g.resourceId,
          aliases: aliases
        };
}

function handleThingTypes(g) {
  var propertyOrSubjectType = function (id) {
    var match = id.thingIdType;
    if (match !== undefined && !match) {
      return /* FACT */0;
    } else {
      return /* NONFACT */1;
    }
  };
  List.iter((function (r) {
          var id = r.thingId;
          id.thingIdType = /* FACT */0;
          return /* () */0;
        }), g.facts);
  List.iter((function (r) {
          var propertyId = r.propertyId;
          propertyId.thingIdType = propertyOrSubjectType(propertyId);
          var subjectId = r.subjectId;
          subjectId.thingIdType = propertyOrSubjectType(subjectId);
          return /* () */0;
        }), g.facts);
  return g;
}

function findId(uniqueIds, thingId) {
  return List.find((function (e) {
                return Caml_obj.caml_equal(thingIdKey(e), thingIdKey(thingId));
              }), uniqueIds);
}

function _convertValue($$package, uniqueIds, fact) {
  var match = fact.value;
  if (match.tag) {
    return /* Id */Block.__(1, [match[0]]);
  } else {
    var str = match[0];
    var __x = $$package.aliases;
    var alias = Js_dict.get(__x, str);
    if (alias !== undefined) {
      return /* Id */Block.__(1, [alias]);
    } else {
      var e = Belt_List.getBy(uniqueIds, (function (e) {
              return Caml_obj.caml_equal(thingIdKey(e), /* tuple */[
                          str,
                          undefined
                        ]);
            }));
      if (e !== undefined) {
        return /* Id */Block.__(1, [e]);
      } else {
        return /* String */Block.__(0, [str]);
      }
    }
  }
}

function linkValues(p) {
  var uniqueIds = RList$Rationale.uniqBy(thingIdKey, allPrimaryIds(p));
  List.iter((function (fact) {
          fact.value = _convertValue(p, uniqueIds, fact);
          return /* () */0;
        }), p.facts);
  return p;
}

function convertIdd($$package, thingId) {
  var __x = $$package.aliases;
  var alias = Js_dict.get(__x, Option$Rationale.$$default("", thingId.rawId));
  var match = thingId.rawId;
  if (match !== undefined) {
    var r = match;
    if (alias !== undefined) {
      var match$1 = alias.rawId;
      if (match$1 !== undefined) {
        return match$1;
      }
      
    }
    if (IdConverter$BsKen.isFullId(r)) {
      return r;
    } else {
      return IdConverter$BsKen.toFullId($$package.baseId, $$package.resourceId, r);
    }
  }
  
}

function generateFactId(thingId, subjectId, $$package) {
  var subject = Option$Rationale.toExn("Subject ThingID expected to have updatedID by this point of pipeline", subjectId.updatedId);
  var isInSameBase = Graph_T$BsKen.Directory.root(subject) === $$package.baseId;
  var tagId = Option$Rationale.toExn("Expected fact to have fact ID at this point.", thingId.tag);
  if (isInSameBase) {
    return subject + ("/_f/" + tagId);
  } else {
    return Option$Rationale.toExn("Expect Full Base Id Id", IdConverter$BsKen.toFullId($$package.baseId, $$package.resourceId, "_f/" + tagId));
  }
}

function handleUpdatedIds(p) {
  var uniqueIds = RList$Rationale.uniqBy(thingIdKey, allPrimaryIds(p));
  List.iter((function (id) {
          var match = id.thingIdType;
          if (match !== undefined && match) {
            id.updatedId = convertIdd(p, id);
            return /* () */0;
          } else {
            return /* () */0;
          }
        }), uniqueIds);
  List.iter((function (fact) {
          fact.thingId.updatedId = generateFactId(fact.thingId, fact.subjectId, p);
          return /* () */0;
        }), p.facts);
  return p;
}

function showFacts(g) {
  return $$Array.map(Compiler_AST$BsKen.factToJs, $$Array.of_list(g.facts));
}

function showIds(g) {
  return $$Array.map(Compiler_AST$BsKen.thingIdToJs, $$Array.of_list(RList$Rationale.uniqBy(thingIdKey, allPrimaryIds(g))));
}

function inverseFact(fact) {
  var match = fact.value;
  if (match.tag) {
    return {
            thingId: fact.thingId,
            subjectId: match[0],
            propertyId: fact.propertyId,
            isInversed: false,
            value: /* Id */Block.__(1, [fact.subjectId])
          };
  } else {
    return {
            thingId: fact.thingId,
            subjectId: {
              rawId: match[0],
              tag: undefined,
              thingIdType: undefined,
              updatedId: undefined
            },
            propertyId: fact.propertyId,
            isInversed: false,
            value: /* Id */Block.__(1, [fact.subjectId])
          };
  }
}

function handleInverseFacts($$package) {
  return {
          facts: List.map((function (f) {
                  var match = f.isInversed;
                  if (match) {
                    return inverseFact(f);
                  } else {
                    return f;
                  }
                }), $$package.facts),
          baseId: $$package.baseId,
          resourceId: $$package.resourceId,
          aliases: $$package.aliases
        };
}

function run(param) {
  return Function$Rationale.Infix.$pipe$pipe$great((function (param) {
                return Function$Rationale.Infix.$pipe$pipe$great((function (param) {
                              return Function$Rationale.Infix.$pipe$pipe$great((function (param) {
                                            return Function$Rationale.Infix.$pipe$pipe$great((function (param) {
                                                          return Function$Rationale.Infix.$pipe$pipe$great(handleInverseFacts, tagFacts, param);
                                                        }), useUniqueThingIds, param);
                                          }), handleThingTypes, param);
                            }), linkValues, param);
              }), handleUpdatedIds, param);
}

function convertId(f) {
  return {
          id: Option$Rationale.toExn("", f.updatedId),
          isPublic: false
        };
}

function toSimple(g) {
  return List.map((function (f) {
                var match = f.value;
                var tmp;
                if (match.tag) {
                  var id = match[0];
                  tmp = /* ThingId */Block.__(1, [Option$Rationale.toExn("Error: thingId does not have #updatedId when needed: " + Option$Rationale.$$default("", id.rawId), id.updatedId)]);
                } else {
                  tmp = /* String */Block.__(0, [match[0]]);
                }
                return {
                        id: convertId(f.thingId),
                        subjectId: convertId(f.subjectId),
                        propertyId: convertId(f.propertyId),
                        value: {
                          valueType: tmp
                        }
                      };
              }), g.facts);
}

exports.makeThingId = makeThingId;
exports.thingIdKey = thingIdKey;
exports.allPrimaryIds = allPrimaryIds;
exports.findUniqueIds = findUniqueIds;
exports.tagFacts = tagFacts;
exports.useUniqueThingIds = useUniqueThingIds;
exports.handleThingTypes = handleThingTypes;
exports.findId = findId;
exports._convertValue = _convertValue;
exports.linkValues = linkValues;
exports.convertIdd = convertIdd;
exports.generateFactId = generateFactId;
exports.handleUpdatedIds = handleUpdatedIds;
exports.showFacts = showFacts;
exports.showIds = showIds;
exports.inverseFact = inverseFact;
exports.handleInverseFacts = handleInverseFacts;
exports.run = run;
exports.convertId = convertId;
exports.toSimple = toSimple;
/* Graph_T-BsKen Not a pure module */
